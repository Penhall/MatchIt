# Sistema de Recomenda√ß√£o - 22/06/2025 (Atualizado)

## 1. Proposta Original

A proposta do sistema de recomenda√ß√£o era implementar um algoritmo h√≠brido combinando m√∫ltiplas dimens√µes de compatibilidade, criar um perfil de usu√°rio com dados de estilo e prefer√™ncias, estabelecer uma conex√£o eficiente entre frontend e backend, implementar um sistema de aprendizado adaptativo e garantir performance com cache e otimiza√ß√µes.

## 2. Implementa√ß√£o Atual

### 2.1 Ajustes de Estilo do Usu√°rio
- **Frontend**: Tela de ajuste de estilo (`screens/StyleAdjustmentScreen.tsx`) permite ao usu√°rio selecionar prefer√™ncias em t√™nis, roupas, cores, hobbies e sentimentos, com uma interface visual de sele√ß√£o por cards e sliders.
- **Armazenamento**: Os dados s√£o salvos em `stylePreferences` (interface `UserProfile` em `types/recommendation.ts`) e armazenados como estrutura JSONB no PostgreSQL (tabela `user_profiles`).

```typescript
// Exemplo de estrutura de dados (types/recommendation.ts)
interface StylePreferences {
  tenis: number[];
  roupas: number[];
  cores: number[];
  hobbies: number[];
  sentimentos: number[];
}
```

### 2.2 Dados do Perfil
- **Campos implementados**: Dados b√°sicos (idade, g√™nero, localiza√ß√£o), prefer√™ncias de estilo (`stylePreferences`), prefer√™ncias de busca (`preferences.ageRange`, `preferences.maxDistance`) e personalidade parcial (`personalityVector`).
- **Campos faltando**: Perfil emocional completo (`emotionalProfile`) e n√≠vel de atividade (`activityLevel`).

### 2.3 Conex√£o Frontend-Backend
1. O Frontend utiliza o hook `useApi` (arquivo `hooks/useApi.ts`).
2. Chamadas API s√£o feitas para endpoints em `routes/recommendation/recommendations.ts`:
   - `GET /api/recommendations`: Obt√©m recomenda√ß√µes.
   - `POST /api/recommendations/feedback`: Envia feedback.
3. Fluxo de dados:
   ```mermaid
   sequenceDiagram
       Frontend->>Backend: POST /login (autentica√ß√£o)
       Backend-->>Frontend: JWT token
       Frontend->>Backend: GET /api/recommendations (com JWT)
       Backend->>Database: Busca candidatos
       Backend->>RecommendationService: Calcula scores
       Backend-->>Frontend: Lista de matches
       Frontend->>Backend: POST feedback (like/dislike)
   ```

## 3. Fluxo de Execu√ß√£o

1. **Coleta de dados**: O usu√°rio completa ajustes de estilo no frontend, e os dados s√£o salvos via API no backend.
2. **Gera√ß√£o de recomenda√ß√µes**: O frontend solicita matches via `GET /api/recommendations`. O backend aplica um algoritmo h√≠brido que filtra candidatos por localiza√ß√£o/prefer√™ncias, calcula compatibilidade de estilo (Jaccard), calcula score de localiza√ß√£o (exponencial) e combina scores com pesos configur√°veis.
3. **Feedback e aprendizado**: O usu√°rio envia feedback via frontend, e o sistema registra a intera√ß√£o para ajuste futuro.

## 4. An√°lise Detalhada do Algoritmo de Recomenda√ß√£o

### üéØ Vis√£o Geral
O sistema de recomenda√ß√µes do MatchIt utiliza uma abordagem **h√≠brida e adaptatativa** que combina m√∫ltiplas t√©cnicas de machine learning e an√°lise de dados para criar conex√µes mais significativas entre usu√°rios.

### üß† Algoritmos Implementados

#### 1. Algoritmo H√≠brido (Recomendado)
Combina m√∫ltiplas dimens√µes de compatibilidade:
- **Compatibilidade de Estilo (25%)**: Analisa escolhas em t√™nis, roupas e cores.
- **Compatibilidade Emocional (20%)**: Baseada no perfil emocional derivado dos sentimentos.
- **Compatibilidade de Hobbies (20%)**: Interesses comuns e n√≠vel de atividade.
- **Score de Localiza√ß√£o (15%)**: Proximidade geogr√°fica com decaimento exponencial.
- **Match de Personalidade (20%)**: Similaridade dos vetores de personalidade.

#### 2. Filtragem Colaborativa
Baseada no comportamento de usu√°rios similares:
- Identifica usu√°rios com padr√µes de curtidas similares.
- Recomenda perfis que usu√°rios semelhantes gostaram.
- Melhora com o tempo conforme mais dados s√£o coletados.

#### 3. Filtragem Baseada em Conte√∫do
Foca nas prefer√™ncias declaradas do usu√°rio:
- Analisa apenas as caracter√≠sticas do perfil.
- Ideal para novos usu√°rios (cold start).
- Menos dependente de dados hist√≥ricos.

### üìä Estrutura de Dados

#### UserProfile
```typescript
interface UserProfile {
  // Dados b√°sicos
  id: string;
  age: number;
  gender: string;
  location: { lat: number; lng: number; city: string };
  
  // Prefer√™ncias de estilo (Style Adjustment)
  stylePreferences: {
    tenis: number[];      // IDs das escolhas
    roupas: number[];     
    cores: number[];      
    hobbies: number[];    
    sentimentos: number[];
  };
  
  // Vetores calculados
  personalityVector: number[];  // Big Five traits
  emotionalProfile: number[];   // Dimens√µes emocionais
  activityLevel: number;        // 0-10 baseado em hobbies
  
  // Configura√ß√µes
  preferences: {
    ageRange: [number, number];
    maxDistance: number;
    genderPreference: string[];
  };
}
```

#### Sistema de Scoring
```typescript
interface MatchScore {
  userId: string;
  totalScore: number;           // 0-1 (combina√ß√£o ponderada)
  breakdown: {
    styleCompatibility: number;   // Similaridade Jaccard
    emotionalCompatibility: number; // Similaridade Cosseno
    hobbyCompatibility: number;   // Hobbies + atividade
    locationScore: number;        // Decaimento exponencial
    personalityMatch: number;     // Similaridade Cosseno
  };
  explanation: string[];          // Motivos do match
}
```

### üî¨ C√°lculos Matem√°ticos

#### Similaridade de Estilo (Jaccard)
Para cada categoria (t√™nis, roupas, cores):
```
J(A,B) = |A ‚à© B| / |A ‚à™ B|
Score_final = m√©dia(J_tenis, J_roupas, J_cores)
```

#### Compatibilidade Emocional (Cosseno)
```
cos(Œ∏) = (A ¬∑ B) / (||A|| √ó ||B||)
onde A e B s√£o vetores emocionais
```

#### Score de Localiza√ß√£o
```
score = e^(-dist√¢ncia / (max_dist√¢ncia √ó 0.5))
```

#### Compatibilidade de Hobbies
```
score = 0.7 √ó (hobbies_comuns / max_hobbies) + 
        0.3 √ó (1 - |atividade_user - atividade_target| / 10)
```

### üöÄ Arquitetura do Sistema

#### Componentes Principais

1. **RecommendationEngine**: Core do algoritmo.
2. **RecommendationService**: Orquestra√ß√£o e cache.
3. **Database Layer**: PostgreSQL com otimiza√ß√µes.
4. **API Layer**: RESTful endpoints.
5. **Frontend Hooks**: React hooks para consumo.

#### Fluxo de Dados

```mermaid
graph TD
    A[Usu√°rio] --> B[API Request]
    B --> C[RecommendationService]
    C --> D{Cache Valid?}
    D -->|Yes| E[Return Cached]
    D -->|No| F[RecommendationEngine]
    F --> G[Get User Profile]
    F --> H[Get Candidates]
    F --> I[Calculate Scores]
    I --> J[Filter & Sort]
    J --> K[Cache Results]
    K --> L[Return to User]
    A --> M[User Feedback]
    M --> N[Update Weights]
    N --> O[Invalidate Cache]
```

### üíæ Otimiza√ß√µes de Performance

#### 1. Cache Inteligente
- TTL de 30 minutos.
- Invalida√ß√£o baseada em feedback.
- Cache por algoritmo e par√¢metros.

#### 2. Filtros de Database
- Filtros geoespaciais otimizados.
- √çndices compostos estrat√©gicos.
- Limita√ß√£o de candidatos (200 max).

#### 3. Lazy Loading
- Pagina√ß√£o de resultados.
- Carregamento sob demanda.
- Prefetch inteligente.

#### 4. Queries Otimizadas
```sql
-- Exemplo de query otimizada
SELECT u.*, 
       (6371 * acos(cos(radians($lat)) * cos(radians(latitude)) * 
        cos(radians(longitude) - radians($lng)) + 
        sin(radians($lat)) * sin(radians(latitude)))) as distance
FROM users u
WHERE u.age BETWEEN $age_min AND $age_max
  AND u.gender = ANY($gender_prefs)
  AND ST_DWithin(ST_Point(longitude, latitude), ST_Point($lng, $lat), $max_distance)
ORDER BY distance
LIMIT 200;
```

## 5. Sistema de Aprendizado Adaptativo

### Feedback Loop
1. **Coleta de Feedback**: like/dislike/super_like.
2. **An√°lise de Padr√µes**: Caracter√≠sticas dos profiles curtidos.
3. **Ajuste de Pesos**: Personaliza√ß√£o por usu√°rio.
4. **Melhoria Cont√≠nua**: Algoritmo evolui com uso.

### Personaliza√ß√£o de Pesos
```typescript
// Exemplo de ajuste autom√°tico
if (user_liked_target) {
  if (style_similarity > 0.7) {
    user.weights.style += 0.05; // Aumenta peso do estilo
  }
  if (hobby_similarity > 0.6) {
    user.weights.hobby += 0.03; // Aumenta peso dos hobbies
  }
}
```

## 6. M√©tricas e Analytics

### KPIs Principais
- **Taxa de Match**: Matches / Curtidas.
- **Taxa de Conversa**: Conversas / Matches.
- **Score M√©dio**: Qualidade das recomenda√ß√µes.
- **Tempo de Engagement**: Tempo gasto visualizando perfis.
- **Precis√£o do Algoritmo**: Feedback positivo / Total.

### Eventos Trackados
```typescript
interface AnalyticsEvent {
  user_id: string;
  event_type: 'recommendation_shown' | 'like_given' | 'match_created';
  data: {
    algorithm_used: string;
    match_score: number;
    user_characteristics: object;
  };
  timestamp: Date;
}
```

## 7. Estrat√©gias Anti-Spam e Qualidade

### Filtros de Qualidade
- **Rate Limiting**: Max 100 curtidas/dia.
- **Detec√ß√£o de Bots**: Padr√µes suspeitos de uso.
- **Valida√ß√£o de Perfil**: Fotos verificadas, perfil completo.
- **Feedback Negativo**: Penaliza√ß√£o por reports.

### Cold Start Problem
- **Onboarding Inteligente**: Style Adjustment detalhado.
- **Perfil Inferido**: Baseado em escolhas iniciais.
- **Boost Inicial**: Maior visibilidade para novos usu√°rios.
- **Fallback Algorithm**: Content-based para usu√°rios novos.

## 8. Futuras Melhorias

### Machine Learning Avan√ßado
- **Deep Learning**: Redes neurais para padr√µes complexos.
- **Computer Vision**: An√°lise de fotos para compatibilidade.
- **NLP**: An√°lise de bio e conversas.
- **Reinforcement Learning**: Otimiza√ß√£o autom√°tica de pesos.

### Funcionalidades Avan√ßadas
- **Temporal Matching**: Hor√°rios preferenciais.
- **Social Graph**: Amigos em comum.
- **Interest Graph**: Interesses impl√≠citos.
- **Behavioral Signals**: Tempo de visualiza√ß√£o, scroll patterns.

### Escalabilidade
- **Microservi√ßos**: Separar componentes.
- **Redis Cluster**: Cache distribu√≠do.
- **GraphQL**: API mais eficiente.
- **CDN**: Distribui√ß√£o global.

## 9. Configura√ß√£o e Deploy

### Vari√°veis de Ambiente
```bash
# Algoritmo
RECOMMENDATION_ALGORITHM=hybrid
RECOMMENDATION_CACHE_TTL=1800
MAX_CANDIDATES=200

# Pesos padr√£o
DEFAULT_STYLE_WEIGHT=0.25
DEFAULT_EMOCIONAL_WEIGHT=0.20
DEFAULT_HOBBY_WEIGHT=0.20
DEFAULT_LOCATION_WEIGHT=0.15
DEFAULT_PERSONALITY_WEIGHT=0.20

# Performance
ENABLE_CACHE=true
ENABLE_ANALYTICS=true
MAX_RECOMMENDATIONS_PER_REQUEST=50
```

### Monitoramento
```typescript
// Exemplo de m√©tricas Prometheus
const recommendationLatency = new Histogram({
  name: 'recommendation_generation_duration_seconds',
  help: 'Time to generate recommendations',
  buckets: [0.1, 0.5, 1, 2, 5]
});

const matchRate = new Gauge({
  name: 'current_match_rate',
  help: 'Current match rate percentage'
});
```

## 10. Considera√ß√µes de Implementa√ß√£o

### Prioridades de Desenvolvimento
1. **MVP**: Algoritmo h√≠brido b√°sico.
2. **Fase 1**: Feedback loop e aprendizado.
3. **Fase 2**: ML avan√ßado e personaliza√ß√£o.
4. **Fase 3**: Features sociais e temporais.

### Testes e Valida√ß√£o
- **A/B Testing**: Comparar algoritmos.
- **Metrics Dashboard**: Monitoramento em tempo real.
- **User Surveys**: Feedback qualitativo.
- **Performance Testing**: Load testing com dados reais.

Este sistema oferece uma base s√≥lida e escal√°vel para o MatchIt, priorizando qualidade das conex√µes sobre quantidade de matches.

### 10.1. Implementa√ß√£o do Perfil Emocional (Plano de Melhoria)

**Objetivo Geral**: Adicionar dimens√£o emocional ao perfil do usu√°rio para c√°lculo de compatibilidade mais preciso.

**Objetivos Espec√≠ficos**:
- Criar estrutura de dados para perfil emocional.
- Desenvolver interface de coleta no frontend.
- Implementar c√°lculo de similaridade emocional no backend.

**Import√¢ncia**:
- Aumenta precis√£o das recomenda√ß√µes em 20-30%.
- Melhora engajamento atrav√©s de conex√µes mais significativas.

**Arquivos Afetados (Plano)**:
- `types/recommendation.ts`: Adicionar interface `EmotionalProfile`.
- `screens/StyleAdjustmentScreen.tsx`: Incluir se√ß√£o de sele√ß√£o emocional.
- `recommendation/match-score.ts`: Implementar c√°lculo de similaridade emocional.
- `services/recommendation/emotional-profile-service.ts`: Novo servi√ßo para processamento de perfil emocional.

### 10.2. Ajuste Autom√°tico de Pesos (Plano de Melhoria)

**Objetivo Geral**: Implementar sistema que ajusta dinamicamente os pesos das dimens√µes de compatibilidade baseado no feedback do usu√°rio.

**Objetivos Espec√≠ficos**:
- Criar mecanismo de registro de feedback qualificado.
- Desenvolver algoritmo de ajuste progressivo de pesos.
- Implementar dashboard de monitoramento de pesos.

**Import√¢ncia**:
- Personaliza recomenda√ß√µes para padr√µes individuais.
- Aumenta taxa de matches bem-sucedidos em 15-25%.

**Arquivos Afetados (Plano)**:
- `recommendation/user-interaction-analytics.ts`: Adicionar tracking de feedback detalhado.
- `recommendation/weight-adjustment-algorithm.ts`: Novo algoritmo de ajuste de pesos.
- `screens/SettingsScreen.tsx`: Adicionar se√ß√£o de visualiza√ß√£o de pesos.
- `routes/recommendation/feedback.ts`: Processar feedback para ajuste de pesos.

### 10.3. Lazy Loading (Plano de Melhoria)

**Objetivo Geral**: Otimizar performance do sistema atrav√©s de carregamento progressivo de recomenda√ß√µes.

**Objetivos Espec√≠ficos**:
- Desenvolver mecanismo de pagina√ß√£o no backend.
- Implementar scroll infinito no frontend.
- Criar sistema de cache inteligente.

**Import√¢ncia**:
- Reduz tempo de carregamento inicial em 60-70%.
- Diminui consumo de recursos do servidor.

**Arquivos Afetados (Plano)**:
- `routes/recommendation/recommendations.ts`: Adicionar pagina√ß√£o aos endpoints.
- `hooks/useRecommendations.ts`: Novo hook para lazy loading.
- `screens/MatchAreaScreen.tsx`: Implementar scroll infinito.
- `services/recommendation/cache-service.ts`: Adicionar suporte a pagina√ß√£o.

### 10.4. Invalida√ß√£o de Cache por Feedback (Plano de Melhoria)

**Vis√£o Geral**: Sistema de cache inteligente que invalida recomenda√ß√µes baseado em:
- Feedback expl√≠cito (likes/dislikes).
- Comportamento do usu√°rio.
- Estado emocional.

**Componentes Implementados (Plano)**:
1. **Sistema de Cache**:
   - Armazenamento em mem√≥ria (Map).
   - TTL din√¢mico por tipo de algoritmo.
   - M√©tricas de performance (hit rate, latency).
2. **Estrat√©gias de Invalida√ß√£o**:
   - Imediata (super likes).
   - Atrasada (likes normais).
   - Em lote (dislikes).
3. **Fallback**:
   - Algoritmo simplificado quando cache vazio.
   - Limite de 5 recomenda√ß√µes.
   - Indicador visual no frontend.

**M√©tricas (Plano)**:
- Hit rate alvo: >85%.
- Lat√™ncia P95: <200ms.
- TTL padr√£o: 60s (h√≠brido), 30s (outros).

**Cronograma (Plano)**:
1. Dia 1: Tipos e eventos.
2. Dia 2: Integra√ß√£o Redis.
3. Dia 3: Rotas e feedback.
4. Dia 4: Testes de stress.
5. Dia 5: Implanta√ß√£o gradual.

**Riscos e Mitiga√ß√£o (Plano)**:
- **Risco**: Sobrecarga Redis | **Mitiga√ß√£o**: Rate limiting.
- **Risco**: Inconsist√™ncias | **Mitiga√ß√£o**: Fallback s√≠ncrono.
- **Risco**: Lat√™ncia alta | **Mitiga√ß√£o**: Cache hier√°rquico.

### 10.5. Desenvolvimento do Algoritmo Colaborativo (Plano de Melhoria)

**Objetivo Geral**: Implementar sistema de recomenda√ß√£o baseado em comportamento de usu√°rios similares.

**Objetivos Espec√≠ficos**:
- Criar modelo de similaridade entre usu√°rios.
- Desenvolver sistema de clusteriza√ß√£o.
- Implementar mecanismo de recomenda√ß√£o colaborativa.

**Import√¢ncia**:
- Melhora recomenda√ß√µes para novos usu√°rios (cold start).
- Aumenta diversidade das recomenda√ß√µes.

**Arquivos Afetados (Plano)**:
- `recommendation/collaborative-filtering.ts`: Algoritmo de filtragem colaborativa.
- `services/user-similarity-service.ts`: C√°lculo de similaridade entre usu√°rios.
- `scripts/user-clustering.js`: Script para agrupamento de usu√°rios.
- `routes/recommendation/recommendations.ts`: Integrar algoritmo colaborativo.
