#!/bin/bash
# scripts/corrigir-jwt-malformed.sh - Corre√ß√£o espec√≠fica do problema JWT malformed

set -e

# Cores
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

echo -e "${BLUE}üîß CORRE√á√ÉO: JWT MALFORMED${NC}"
echo ""
echo -e "${YELLOW}üéØ PROBLEMA IDENTIFICADO:${NC}"
echo -e "   ‚Ä¢ Registro funcionando ‚úÖ"
echo -e "   ‚Ä¢ Token sendo gerado ‚úÖ"
echo -e "   ‚Ä¢ JWT_SECRET consistente ‚úÖ"
echo -e "   ‚Ä¢ Erro no /me: 'jwt malformed' ‚ùå"
echo ""
echo -e "${YELLOW}üõ†Ô∏è CAUSA PROV√ÅVEL:${NC}"
echo -e "   ‚Ä¢ Extra√ß√£o incorreta do header Authorization"
echo -e "   ‚Ä¢ Token com caracteres extras ou truncado"
echo -e "   ‚Ä¢ Problema na valida√ß√£o do formato Bearer"
echo ""

echo -e "${BLUE}‚ñ∂ ETAPA 1: Backup do middleware atual${NC}"
cp server/middleware/auth.js server/middleware/auth.js.backup.$(date +%Y%m%d_%H%M%S)
echo -e "${GREEN}‚úÖ Backup criado${NC}"

echo -e "${BLUE}‚ñ∂ ETAPA 2: Criando middleware com debug melhorado${NC}"

cat > server/middleware/auth.js << 'EOF'
// server/middleware/auth.js - Middleware com debug melhorado para JWT malformed
import jwt from 'jsonwebtoken';
import { pool } from '../config/database.js';

const JWT_SECRET = process.env.JWT_SECRET || 'matchit-secret-development-2025';

/**
 * Middleware de autentica√ß√£o com debug melhorado
 */
export const authenticateToken = async (req, res, next) => {
    try {
        console.log('üîç [AUTH DEBUG] Iniciando valida√ß√£o de token...');
        
        // Extrair token do header Authorization
        const authHeader = req.headers.authorization;
        console.log('üîç [AUTH DEBUG] Header Authorization:', authHeader ? `"${authHeader}"` : 'undefined');
        
        if (!authHeader) {
            console.log('‚ùå [AUTH DEBUG] Header Authorization n√£o encontrado');
            return res.status(401).json({
                success: false,
                error: 'Token de acesso obrigat√≥rio',
                code: 'MISSING_TOKEN'
            });
        }
        
        // Verificar formato do token (Bearer <token>)
        if (!authHeader.startsWith('Bearer ')) {
            console.log('‚ùå [AUTH DEBUG] Formato inv√°lido, header:', authHeader);
            return res.status(401).json({
                success: false,
                error: 'Formato de token inv√°lido. Use: Bearer <token>',
                code: 'INVALID_TOKEN_FORMAT'
            });
        }
        
        // Extrair token removendo "Bearer "
        const token = authHeader.substring(7).trim(); // Trim para remover espa√ßos extras
        console.log('üîç [AUTH DEBUG] Token extra√≠do:', `"${token}"`);
        console.log('üîç [AUTH DEBUG] Token length:', token.length);
        console.log('üîç [AUTH DEBUG] Token in√≠cio:', token.substring(0, 20) + '...');
        console.log('üîç [AUTH DEBUG] Token fim:', '...' + token.substring(token.length - 20));
        
        // Verificar se token n√£o est√° vazio
        if (!token || token === 'undefined' || token === 'null') {
            console.log('‚ùå [AUTH DEBUG] Token vazio ou inv√°lido');
            return res.status(401).json({
                success: false,
                error: 'Token vazio',
                code: 'EMPTY_TOKEN'
            });
        }
        
        // Para desenvolvimento, aceitar token "test-token"
        if (process.env.NODE_ENV === 'development' && token === 'test-token') {
            console.log('‚úÖ [AUTH DEBUG] Token de desenvolvimento aceito');
            req.user = {
                id: 1,
                userId: 1,
                name: 'Usu√°rio Teste',
                email: 'teste@matchit.com',
                isTestUser: true
            };
            return next();
        }
        
        // Verificar se o token tem formato JWT b√°sico (3 partes separadas por ponto)
        const tokenParts = token.split('.');
        console.log('üîç [AUTH DEBUG] Partes do token:', tokenParts.length);
        
        if (tokenParts.length !== 3) {
            console.log('‚ùå [AUTH DEBUG] Token n√£o tem 3 partes. Partes encontradas:', tokenParts.length);
            console.log('üîç [AUTH DEBUG] Partes:', tokenParts.map((part, i) => `${i}: ${part.substring(0, 10)}...`));
            return res.status(401).json({
                success: false,
                error: 'Token JWT malformado - partes incorretas',
                code: 'MALFORMED_TOKEN_PARTS'
            });
        }
        
        // Verificar JWT_SECRET
        console.log('üîç [AUTH DEBUG] JWT_SECRET:', JWT_SECRET);
        
        // Verificar e decodificar JWT
        let decoded;
        try {
            console.log('üîç [AUTH DEBUG] Tentando verificar JWT...');
            decoded = jwt.verify(token, JWT_SECRET);
            console.log('‚úÖ [AUTH DEBUG] JWT verificado com sucesso');
            console.log('üîç [AUTH DEBUG] Payload decodificado:', JSON.stringify(decoded, null, 2));
        } catch (jwtError) {
            console.error('‚ùå [AUTH DEBUG] Erro JWT detalhado:', {
                name: jwtError.name,
                message: jwtError.message,
                stack: jwtError.stack
            });
            
            if (jwtError.name === 'TokenExpiredError') {
                return res.status(401).json({
                    success: false,
                    error: 'Token expirado',
                    code: 'TOKEN_EXPIRED'
                });
            } else if (jwtError.name === 'JsonWebTokenError') {
                return res.status(401).json({
                    success: false,
                    error: 'Token inv√°lido: ' + jwtError.message,
                    code: 'INVALID_TOKEN'
                });
            } else {
                return res.status(401).json({
                    success: false,
                    error: 'Falha na valida√ß√£o do token: ' + jwtError.message,
                    code: 'TOKEN_VALIDATION_FAILED'
                });
            }
        }
        
        // Verificar se temos userId no payload
        if (!decoded.userId) {
            console.log('‚ùå [AUTH DEBUG] userId n√£o encontrado no payload');
            return res.status(401).json({
                success: false,
                error: 'Token inv√°lido - userId ausente',
                code: 'MISSING_USERID'
            });
        }
        
        console.log('üîç [AUTH DEBUG] userId do token:', decoded.userId);
        
        // Buscar usu√°rio no banco de dados
        console.log('üîç [AUTH DEBUG] Buscando usu√°rio no banco...');
        const userResult = await pool.query(
            'SELECT id, name, email, is_active FROM users WHERE id = $1',
            [decoded.userId]
        );
        
        if (userResult.rows.length === 0) {
            console.log('‚ùå [AUTH DEBUG] Usu√°rio n√£o encontrado no banco');
            return res.status(401).json({
                success: false,
                error: 'Usu√°rio n√£o encontrado',
                code: 'USER_NOT_FOUND'
            });
        }
        
        const user = userResult.rows[0];
        console.log('‚úÖ [AUTH DEBUG] Usu√°rio encontrado:', user.email);
        
        // Verificar se usu√°rio est√° ativo
        if (!user.is_active) {
            console.log('‚ùå [AUTH DEBUG] Usu√°rio inativo');
            return res.status(401).json({
                success: false,
                error: 'Conta desativada',
                code: 'ACCOUNT_DISABLED'
            });
        }
        
        // Adicionar informa√ß√µes do usu√°rio √† requisi√ß√£o
        req.user = {
            id: user.id,
            userId: user.id, // Para compatibilidade
            name: user.name,
            email: user.email,
            isActive: user.is_active,
            tokenData: decoded
        };
        
        console.log('‚úÖ [AUTH DEBUG] Token validado com sucesso para:', user.email);
        next();
        
    } catch (error) {
        console.error('‚ùå [AUTH DEBUG] Erro geral no middleware:', error);
        res.status(500).json({
            success: false,
            error: 'Erro interno de autentica√ß√£o',
            code: 'AUTH_INTERNAL_ERROR',
            details: process.env.NODE_ENV === 'development' ? error.message : undefined
        });
    }
};

/**
 * Middleware de autentica√ß√£o opcional
 */
export const optionalAuth = async (req, res, next) => {
    try {
        const authHeader = req.headers.authorization;
        
        if (!authHeader || !authHeader.startsWith('Bearer ')) {
            req.user = null;
            return next();
        }
        
        await authenticateToken(req, res, next);
        
    } catch (error) {
        req.user = null;
        next();
    }
};

export default authenticateToken;
EOF

echo -e "${GREEN}‚úÖ Middleware com debug criado${NC}"

echo -e "${BLUE}‚ñ∂ ETAPA 3: Criando script de teste espec√≠fico para JWT${NC}"

cat > scripts/test-jwt-debug.sh << 'EOF'
#!/bin/bash
# scripts/test-jwt-debug.sh - Teste espec√≠fico para debug do JWT

API_URL="http://localhost:3000/api"
TEST_EMAIL="jwt_debug_$(date +%s)@test.com"
TEST_PASSWORD="Test123456"
TEST_NAME="JWT Debug Test"

echo "üîç TESTE DEBUG JWT"
echo ""

# 1. Registrar usu√°rio
echo "1. Registrando usu√°rio..."
REGISTER_DATA='{"email":"'$TEST_EMAIL'","password":"'$TEST_PASSWORD'","name":"'$TEST_NAME'"}'

REGISTER_RESPONSE=$(curl -s -X POST \
    -H "Content-Type: application/json" \
    -d "$REGISTER_DATA" \
    "$API_URL/auth/register")

echo "Resposta do registro:"
echo "$REGISTER_RESPONSE" | jq . 2>/dev/null || echo "$REGISTER_RESPONSE"
echo ""

# 2. Extrair token
TOKEN=$(echo "$REGISTER_RESPONSE" | grep -o '"token":"[^"]*' | cut -d'"' -f4)

if [[ -n "$TOKEN" ]]; then
    echo "‚úÖ Token extra√≠do:"
    echo "   Token: $TOKEN"
    echo "   Length: ${#TOKEN}"
    echo "   In√≠cio: ${TOKEN:0:30}..."
    echo "   Fim: ...${TOKEN: -30}"
    echo ""
    
    # 3. Testar endpoint /me com debug
    echo "2. Testando /me com token..."
    echo "   Authorization header: 'Bearer $TOKEN'"
    echo ""
    
    ME_RESPONSE=$(curl -s -X GET \
        -H "Authorization: Bearer $TOKEN" \
        "$API_URL/auth/me")
    
    echo "Resposta do /me:"
    echo "$ME_RESPONSE" | jq . 2>/dev/null || echo "$ME_RESPONSE"
    
else
    echo "‚ùå Token n√£o encontrado na resposta"
    
    # Tentar login
    echo ""
    echo "Tentando login..."
    LOGIN_DATA='{"email":"'$TEST_EMAIL'","password":"'$TEST_PASSWORD'"}'
    
    LOGIN_RESPONSE=$(curl -s -X POST \
        -H "Content-Type: application/json" \
        -d "$LOGIN_DATA" \
        "$API_URL/auth/login")
    
    echo "Resposta do login:"
    echo "$LOGIN_RESPONSE" | jq . 2>/dev/null || echo "$LOGIN_RESPONSE"
    
    TOKEN=$(echo "$LOGIN_RESPONSE" | grep -o '"token":"[^"]*' | cut -d'"' -f4)
    
    if [[ -n "$TOKEN" ]]; then
        echo ""
        echo "‚úÖ Token do login:"
        echo "   Token: $TOKEN"
        echo ""
        
        ME_RESPONSE=$(curl -s -X GET \
            -H "Authorization: Bearer $TOKEN" \
            "$API_URL/auth/me")
        
        echo "Resposta do /me:"
        echo "$ME_RESPONSE" | jq . 2>/dev/null || echo "$ME_RESPONSE"
    fi
fi
EOF

chmod +x scripts/test-jwt-debug.sh

echo -e "${GREEN}‚úÖ Script de debug JWT criado${NC}"

echo ""
echo -e "${GREEN}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
echo -e "${GREEN} ‚úÖ DEBUG JWT PREPARADO!${NC}"
echo -e "${GREEN}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
echo ""

echo -e "${YELLOW}üöÄ PR√ìXIMOS PASSOS:${NC}"
echo ""
echo -e "${YELLOW}1. Reiniciar o servidor para ativar debug:${NC}"
echo -e "   ${BLUE}Ctrl+C${NC} (parar servidor)"
echo -e "   ${BLUE}npm run server${NC}"
echo ""
echo -e "${YELLOW}2. Executar teste de debug:${NC}"
echo -e "   ${BLUE}./scripts/test-jwt-debug.sh${NC}"
echo ""
echo -e "${YELLOW}3. Analisar logs detalhados no console do servidor${NC}"
echo ""

echo -e "${GREEN}üéØ O QUE O DEBUG VAI MOSTRAR:${NC}"
echo -e "   ‚Ä¢ Como o token est√° sendo extra√≠do"
echo -e "   ‚Ä¢ Se o token tem 3 partes (JWT v√°lido)"
echo -e "   ‚Ä¢ Qual erro espec√≠fico est√° ocorrendo"
echo -e "   ‚Ä¢ Payload decodificado do JWT"
echo ""

echo -e "${YELLOW}‚ö° Reinicie o servidor e execute o debug!${NC}"