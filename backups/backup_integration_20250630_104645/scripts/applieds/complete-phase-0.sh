#!/bin/bash
# complete-phase-0.sh - Completar Fase 0: Integra√ß√£o real com PostgreSQL

# Cores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

echo -e "${BLUE}"
echo "================================================================"
echo " COMPLETANDO FASE 0 - INTEGRA√á√ÉO POSTGRESQL REAL"
echo "================================================================"
echo -e "${NC}"

# Verificar se estamos no diret√≥rio correto
if [ ! -f "package.json" ]; then
    echo -e "${RED}‚ùå Execute este script no diret√≥rio raiz do projeto MatchIt${NC}"
    exit 1
fi

echo -e "${GREEN}‚úÖ Diret√≥rio correto identificado${NC}"

# 1. VERIFICAR E CONFIGURAR POSTGRESQL
echo -e "${BLUE}üóÑÔ∏è  Verificando PostgreSQL...${NC}"

# Verificar se PostgreSQL est√° rodando
if ! pg_isready -h localhost -p 5432 > /dev/null 2>&1; then
    echo -e "${YELLOW}‚ö†Ô∏è  PostgreSQL n√£o est√° rodando. Tentando iniciar...${NC}"
    # Tentar diferentes comandos de inicializa√ß√£o
    if command -v systemctl > /dev/null 2>&1; then
        sudo systemctl start postgresql
    elif command -v service > /dev/null 2>&1; then
        sudo service postgresql start
    elif command -v brew > /dev/null 2>&1; then
        brew services start postgresql
    else
        echo -e "${RED}‚ùå N√£o foi poss√≠vel iniciar PostgreSQL automaticamente${NC}"
        echo "Inicie o PostgreSQL manualmente e execute este script novamente"
        exit 1
    fi
    sleep 3
fi

echo -e "${GREEN}‚úÖ PostgreSQL est√° rodando${NC}"

# 2. CONFIGURAR BANCO DE DADOS
echo -e "${BLUE}üîß Configurando banco de dados...${NC}"

# Verificar se banco exists
DB_EXISTS=$(sudo -u postgres psql -lqt | cut -d \| -f 1 | grep -w matchit_db | wc -l)

if [ $DB_EXISTS -eq 0 ]; then
    echo -e "${YELLOW}‚ö†Ô∏è  Banco matchit_db n√£o existe. Criando...${NC}"
    
    # Criar banco e usu√°rio
    sudo -u postgres psql << EOF
CREATE DATABASE matchit_db OWNER postgres;
CREATE USER matchit WITH PASSWORD 'matchit123';
GRANT ALL PRIVILEGES ON DATABASE matchit_db TO matchit;
ALTER USER matchit CREATEDB;
EOF
    
    echo -e "${GREEN}‚úÖ Banco matchit_db criado${NC}"
else
    echo -e "${GREEN}‚úÖ Banco matchit_db j√° existe${NC}"
fi

# 3. EXECUTAR MIGRA√á√ïES
echo -e "${BLUE}üìä Executando migra√ß√µes...${NC}"

# Verificar se arquivo de migra√ß√£o existe
if [ ! -f "database/migrations/002_complete_style_and_tournament_schema.sql" ]; then
    echo -e "${YELLOW}‚ö†Ô∏è  Arquivo de migra√ß√£o n√£o encontrado. Criando...${NC}"
    
    mkdir -p database/migrations
    
    cat > database/migrations/002_complete_style_and_tournament_schema.sql << 'EOF'
-- database/migrations/002_complete_style_and_tournament_schema.sql
-- Migra√ß√£o completa para Fase 0: Sistema de prefer√™ncias de estilo

BEGIN;

-- Criar tabela users se n√£o existir
CREATE TABLE IF NOT EXISTS users (
    id VARCHAR(255) PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    name VARCHAR(255) NOT NULL,
    date_of_birth DATE,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- Criar tabela de prefer√™ncias de estilo (FASE 0)
CREATE TABLE IF NOT EXISTS style_preferences (
    id SERIAL PRIMARY KEY,
    user_id VARCHAR(255) NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    category VARCHAR(50) NOT NULL,
    question_id VARCHAR(100) NOT NULL,
    selected_option VARCHAR(100) NOT NULL,
    preference_strength DECIMAL(3,2) DEFAULT 1.0,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    UNIQUE(user_id, category, question_id)
);

-- Criar √≠ndices para performance
CREATE INDEX IF NOT EXISTS idx_style_preferences_user_id ON style_preferences(user_id);
CREATE INDEX IF NOT EXISTS idx_style_preferences_category ON style_preferences(category);
CREATE INDEX IF NOT EXISTS idx_style_preferences_user_category ON style_preferences(user_id, category);

-- Inserir usu√°rio de desenvolvimento se n√£o existir
INSERT INTO users (id, email, password_hash, name, date_of_birth) 
VALUES ('dev-user-123', 'dev@matchit.com', '$2b$10$example.hash', 'Usu√°rio de Desenvolvimento', '1990-01-01')
ON CONFLICT (email) DO NOTHING;

-- Inserir algumas prefer√™ncias de exemplo
INSERT INTO style_preferences (user_id, category, question_id, selected_option, preference_strength) 
VALUES 
    ('dev-user-123', 'colors', 'warm_vs_cool', 'warm', 0.8),
    ('dev-user-123', 'styles', 'casual_vs_formal', 'casual', 0.9),
    ('dev-user-123', 'accessories', 'minimal_vs_statement', 'minimal', 0.7)
ON CONFLICT (user_id, category, question_id) DO NOTHING;

COMMIT;
EOF

    echo -e "${GREEN}‚úÖ Arquivo de migra√ß√£o criado${NC}"
fi

# Executar migra√ß√£o
PGPASSWORD=matchit123 psql -h localhost -U matchit -d matchit_db -f database/migrations/002_complete_style_and_tournament_schema.sql

if [ $? -eq 0 ]; then
    echo -e "${GREEN}‚úÖ Migra√ß√£o executada com sucesso${NC}"
else
    echo -e "${RED}‚ùå Erro na migra√ß√£o${NC}"
    exit 1
fi

# 4. CRIAR SERVI√áO DE BANCO DE DADOS
echo -e "${BLUE}üîå Criando servi√ßo de banco de dados...${NC}"

mkdir -p server/config

cat > server/config/database.js << 'EOF'
// server/config/database.js - Configura√ß√£o do banco PostgreSQL
import pkg from 'pg';
const { Pool } = pkg;

// Configura√ß√£o do pool de conex√µes
const pool = new Pool({
    host: process.env.DB_HOST || 'localhost',
    port: process.env.DB_PORT || 5432,
    database: process.env.DB_NAME || 'matchit_db',
    user: process.env.DB_USER || 'matchit',
    password: process.env.DB_PASSWORD || 'matchit123',
    max: 20, // m√°ximo de conex√µes
    idleTimeoutMillis: 30000,
    connectionTimeoutMillis: 2000,
});

// Testar conex√£o
pool.on('connect', () => {
    console.log('üìä Nova conex√£o estabelecida com PostgreSQL');
});

pool.on('error', (err) => {
    console.error('‚ùå Erro no pool PostgreSQL:', err);
});

// Fun√ß√£o helper para queries
export const query = async (text, params) => {
    const start = Date.now();
    try {
        const res = await pool.query(text, params);
        const duration = Date.now() - start;
        console.log(`üîç Query executada: ${duration}ms`);
        return res;
    } catch (error) {
        console.error('‚ùå Erro na query:', error);
        throw error;
    }
};

// Fun√ß√£o para testar conectividade
export const testConnection = async () => {
    try {
        const result = await query('SELECT NOW() as timestamp, version() as version');
        console.log('‚úÖ Banco conectado:', result.rows[0].timestamp);
        return true;
    } catch (error) {
        console.error('‚ùå Falha na conex√£o:', error.message);
        return false;
    }
};

export default pool;
EOF

echo -e "${GREEN}‚úÖ Servi√ßo de banco criado${NC}"

# 5. CRIAR SERVI√áO DE PREFER√äNCIAS DE ESTILO
echo -e "${BLUE}üìã Criando servi√ßo de prefer√™ncias...${NC}"

mkdir -p server/services

cat > server/services/StylePreferencesService.js << 'EOF'
// server/services/StylePreferencesService.js - Servi√ßo de prefer√™ncias de estilo (Fase 0)
import { query } from '../config/database.js';

class StylePreferencesService {
    
    /**
     * Buscar todas as prefer√™ncias de um usu√°rio
     */
    async getUserPreferences(userId) {
        try {
            console.log(`üìã Buscando prefer√™ncias para usu√°rio: ${userId}`);
            
            const result = await query(
                'SELECT * FROM style_preferences WHERE user_id = $1 ORDER BY category, question_id',
                [userId]
            );
            
            // Organizar por categoria
            const preferences = {};
            result.rows.forEach(row => {
                if (!preferences[row.category]) {
                    preferences[row.category] = {};
                }
                preferences[row.category][row.question_id] = {
                    selectedOption: row.selected_option,
                    preferenceStrength: parseFloat(row.preference_strength),
                    updatedAt: row.updated_at
                };
            });
            
            console.log(`‚úÖ Encontradas ${result.rows.length} prefer√™ncias em ${Object.keys(preferences).length} categorias`);
            return preferences;
            
        } catch (error) {
            console.error('‚ùå Erro ao buscar prefer√™ncias:', error);
            throw error;
        }
    }
    
    /**
     * Atualizar prefer√™ncia espec√≠fica
     */
    async updatePreference(userId, category, questionId, selectedOption, preferenceStrength = 1.0) {
        try {
            console.log(`üíæ Atualizando prefer√™ncia: ${userId} -> ${category}/${questionId} = ${selectedOption}`);
            
            const result = await query(`
                INSERT INTO style_preferences (user_id, category, question_id, selected_option, preference_strength, updated_at)
                VALUES ($1, $2, $3, $4, $5, NOW())
                ON CONFLICT (user_id, category, question_id)
                DO UPDATE SET 
                    selected_option = EXCLUDED.selected_option,
                    preference_strength = EXCLUDED.preference_strength,
                    updated_at = NOW()
                RETURNING *
            `, [userId, category, questionId, selectedOption, preferenceStrength]);
            
            console.log(`‚úÖ Prefer√™ncia atualizada: ID ${result.rows[0].id}`);
            return result.rows[0];
            
        } catch (error) {
            console.error('‚ùå Erro ao atualizar prefer√™ncia:', error);
            throw error;
        }
    }
    
    /**
     * Atualizar m√∫ltiplas prefer√™ncias de uma vez
     */
    async updateMultiplePreferences(userId, preferences) {
        try {
            console.log(`üíæ Atualizando ${Object.keys(preferences).length} categorias para usu√°rio: ${userId}`);
            
            const updatedPreferences = [];
            
            for (const [category, categoryPrefs] of Object.entries(preferences)) {
                for (const [questionId, data] of Object.entries(categoryPrefs)) {
                    const selectedOption = typeof data === 'string' ? data : data.selectedOption;
                    const preferenceStrength = typeof data === 'object' ? data.preferenceStrength || 1.0 : 1.0;
                    
                    const result = await this.updatePreference(userId, category, questionId, selectedOption, preferenceStrength);
                    updatedPreferences.push(result);
                }
            }
            
            console.log(`‚úÖ ${updatedPreferences.length} prefer√™ncias atualizadas com sucesso`);
            return updatedPreferences;
            
        } catch (error) {
            console.error('‚ùå Erro ao atualizar m√∫ltiplas prefer√™ncias:', error);
            throw error;
        }
    }
    
    /**
     * Obter estat√≠sticas de completude do perfil
     */
    async getCompletionStats(userId) {
        try {
            console.log(`üìä Calculando estat√≠sticas para usu√°rio: ${userId}`);
            
            // Buscar todas as prefer√™ncias do usu√°rio
            const result = await query(
                'SELECT category, COUNT(*) as count FROM style_preferences WHERE user_id = $1 GROUP BY category',
                [userId]
            );
            
            // Categorias esperadas (pode ser configur√°vel)
            const expectedCategories = ['colors', 'styles', 'accessories', 'shoes', 'patterns'];
            const expectedQuestionsPerCategory = 5; // m√©dia
            
            const completedCategories = result.rows.length;
            const totalExpectedQuestions = expectedCategories.length * expectedQuestionsPerCategory;
            const totalAnsweredQuestions = result.rows.reduce((sum, row) => sum + parseInt(row.count), 0);
            
            const completionPercentage = Math.round((totalAnsweredQuestions / totalExpectedQuestions) * 100);
            
            const stats = {
                totalCategories: expectedCategories.length,
                completedCategories,
                totalExpectedQuestions,
                totalAnsweredQuestions,
                completionPercentage: Math.min(completionPercentage, 100),
                categoriesDetail: result.rows.reduce((acc, row) => {
                    acc[row.category] = parseInt(row.count);
                    return acc;
                }, {})
            };
            
            console.log(`üìä Estat√≠sticas calculadas: ${completionPercentage}% completo`);
            return stats;
            
        } catch (error) {
            console.error('‚ùå Erro ao calcular estat√≠sticas:', error);
            throw error;
        }
    }
    
    /**
     * Remover todas as prefer√™ncias de um usu√°rio
     */
    async clearUserPreferences(userId) {
        try {
            console.log(`üóëÔ∏è  Removendo todas as prefer√™ncias do usu√°rio: ${userId}`);
            
            const result = await query(
                'DELETE FROM style_preferences WHERE user_id = $1',
                [userId]
            );
            
            console.log(`‚úÖ ${result.rowCount} prefer√™ncias removidas`);
            return { deletedCount: result.rowCount };
            
        } catch (error) {
            console.error('‚ùå Erro ao remover prefer√™ncias:', error);
            throw error;
        }
    }
    
    /**
     * Buscar prefer√™ncias por categoria
     */
    async getPreferencesByCategory(userId, category) {
        try {
            console.log(`üìã Buscando prefer√™ncias da categoria '${category}' para usu√°rio: ${userId}`);
            
            const result = await query(
                'SELECT * FROM style_preferences WHERE user_id = $1 AND category = $2 ORDER BY question_id',
                [userId, category]
            );
            
            const preferences = {};
            result.rows.forEach(row => {
                preferences[row.question_id] = {
                    selectedOption: row.selected_option,
                    preferenceStrength: parseFloat(row.preference_strength),
                    updatedAt: row.updated_at
                };
            });
            
            console.log(`‚úÖ Encontradas ${result.rows.length} prefer√™ncias na categoria '${category}'`);
            return preferences;
            
        } catch (error) {
            console.error(`‚ùå Erro ao buscar prefer√™ncias da categoria '${category}':`, error);
            throw error;
        }
    }
}

// Exportar inst√¢ncia singleton
const stylePreferencesService = new StylePreferencesService();
export default stylePreferencesService;
EOF

echo -e "${GREEN}‚úÖ Servi√ßo de prefer√™ncias criado${NC}"

# 6. ATUALIZAR ROTAS DE PERFIL PARA USAR BANCO REAL
echo -e "${BLUE}üõ£Ô∏è  Atualizando rotas de perfil...${NC}"

# Backup das rotas atuais
cp server/routes/profile.js "server/routes/profile.js.backup.$(date +%Y%m%d_%H%M%S)"

cat > server/routes/profile.js << 'EOF'
// server/routes/profile.js - Rotas de Perfil com PostgreSQL (ES Modules)
import express from 'express';
import { optionalAuth } from '../middleware/authMiddleware.js';
import stylePreferencesService from '../services/StylePreferencesService.js';

const router = express.Router();

console.log('üë§ Carregando rotas de perfil com PostgreSQL...');

/**
 * GET /api/profile
 * Buscar dados b√°sicos do perfil do usu√°rio
 */
router.get('/', optionalAuth, async (req, res) => {
    try {
        const userId = req.user?.userId || req.user?.id;
        console.log('üì• GET /api/profile - userId:', userId);
        
        // Buscar estat√≠sticas de completude
        const completionStats = await stylePreferencesService.getCompletionStats(userId);
        
        const userData = {
            id: userId,
            name: req.user?.name || 'Usu√°rio MatchIt',
            email: req.user?.email || 'user@matchit.com',
            createdAt: new Date('2024-01-01'),
            profileCompletion: completionStats.completionPercentage,
            hasStylePreferences: completionStats.totalAnsweredQuestions > 0,
            preferences: {
                ageRange: [22, 35],
                maxDistance: 50,
                interests: ['m√∫sica', 'viagem', 'tecnologia']
            },
            styleStats: completionStats
        };
        
        res.json({
            success: true,
            data: userData,
            timestamp: new Date().toISOString()
        });
        
    } catch (error) {
        console.error('‚ùå Erro em GET /api/profile:', error);
        res.status(500).json({
            success: false,
            error: 'Erro interno do servidor',
            code: 'INTERNAL_ERROR'
        });
    }
});

/**
 * GET /api/profile/style-preferences
 * Buscar prefer√™ncias de estilo do usu√°rio
 */
router.get('/style-preferences', optionalAuth, async (req, res) => {
    try {
        const userId = req.user?.userId || req.user?.id;
        const { category } = req.query;
        
        console.log('üì• GET /api/profile/style-preferences - userId:', userId, 'category:', category);
        
        let preferences;
        if (category) {
            preferences = { [category]: await stylePreferencesService.getPreferencesByCategory(userId, category) };
        } else {
            preferences = await stylePreferencesService.getUserPreferences(userId);
        }
        
        res.json({
            success: true,
            data: preferences,
            count: Object.keys(preferences).length,
            timestamp: new Date().toISOString()
        });
        
    } catch (error) {
        console.error('‚ùå Erro em GET /api/profile/style-preferences:', error);
        res.status(500).json({
            success: false,
            error: 'Erro ao buscar prefer√™ncias de estilo',
            code: 'FETCH_PREFERENCES_ERROR'
        });
    }
});

/**
 * PUT /api/profile/style-preferences
 * Atualizar prefer√™ncia espec√≠fica
 */
router.put('/style-preferences', optionalAuth, async (req, res) => {
    try {
        const userId = req.user?.userId || req.user?.id;
        const { category, questionId, selectedOption, preferenceStrength } = req.body;
        
        console.log('üì• PUT /api/profile/style-preferences:', { userId, category, questionId, selectedOption });
        
        if (!category || !questionId || !selectedOption) {
            return res.status(400).json({
                success: false,
                error: 'Campos obrigat√≥rios: category, questionId, selectedOption',
                code: 'MISSING_REQUIRED_FIELDS'
            });
        }
        
        const updatedPreference = await stylePreferencesService.updatePreference(
            userId, category, questionId, selectedOption, preferenceStrength || 1.0
        );
        
        res.json({
            success: true,
            message: 'Prefer√™ncia atualizada com sucesso',
            data: {
                id: updatedPreference.id,
                category: updatedPreference.category,
                questionId: updatedPreference.question_id,
                selectedOption: updatedPreference.selected_option,
                preferenceStrength: parseFloat(updatedPreference.preference_strength),
                updatedAt: updatedPreference.updated_at
            },
            timestamp: new Date().toISOString()
        });
        
    } catch (error) {
        console.error('‚ùå Erro em PUT /api/profile/style-preferences:', error);
        res.status(500).json({
            success: false,
            error: 'Erro ao atualizar prefer√™ncia',
            code: 'UPDATE_PREFERENCE_ERROR'
        });
    }
});

/**
 * POST /api/profile/style-preferences/batch
 * Atualizar m√∫ltiplas prefer√™ncias de uma vez
 */
router.post('/style-preferences/batch', optionalAuth, async (req, res) => {
    try {
        const userId = req.user?.userId || req.user?.id;
        const { preferences } = req.body;
        
        console.log('üì• POST /api/profile/style-preferences/batch:', { userId, categories: Object.keys(preferences || {}) });
        
        if (!preferences || typeof preferences !== 'object') {
            return res.status(400).json({
                success: false,
                error: 'Campo "preferences" √© obrigat√≥rio e deve ser um objeto',
                code: 'INVALID_PREFERENCES_FORMAT'
            });
        }
        
        const updatedPreferences = await stylePreferencesService.updateMultiplePreferences(userId, preferences);
        
        res.json({
            success: true,
            message: `${updatedPreferences.length} prefer√™ncias atualizadas com sucesso`,
            data: updatedPreferences.map(pref => ({
                id: pref.id,
                category: pref.category,
                questionId: pref.question_id,
                selectedOption: pref.selected_option,
                preferenceStrength: parseFloat(pref.preference_strength),
                updatedAt: pref.updated_at
            })),
            totalUpdated: updatedPreferences.length,
            timestamp: new Date().toISOString()
        });
        
    } catch (error) {
        console.error('‚ùå Erro em POST /api/profile/style-preferences/batch:', error);
        res.status(500).json({
            success: false,
            error: 'Erro ao atualizar prefer√™ncias em lote',
            code: 'BATCH_UPDATE_ERROR'
        });
    }
});

/**
 * GET /api/profile/style-preferences/stats
 * Estat√≠sticas de completude do perfil
 */
router.get('/style-preferences/stats', optionalAuth, async (req, res) => {
    try {
        const userId = req.user?.userId || req.user?.id;
        
        const stats = await stylePreferencesService.getCompletionStats(userId);
        
        res.json({
            success: true,
            data: stats,
            timestamp: new Date().toISOString()
        });
        
    } catch (error) {
        console.error('‚ùå Erro em GET /api/profile/style-preferences/stats:', error);
        res.status(500).json({
            success: false,
            error: 'Erro ao buscar estat√≠sticas',
            code: 'STATS_ERROR'
        });
    }
});

/**
 * DELETE /api/profile/style-preferences
 * Remover todas as prefer√™ncias do usu√°rio
 */
router.delete('/style-preferences', optionalAuth, async (req, res) => {
    try {
        const userId = req.user?.userId || req.user?.id;
        
        const result = await stylePreferencesService.clearUserPreferences(userId);
        
        res.json({
            success: true,
            message: 'Todas as prefer√™ncias foram removidas',
            data: result,
            timestamp: new Date().toISOString()
        });
        
    } catch (error) {
        console.error('‚ùå Erro em DELETE /api/profile/style-preferences:', error);
        res.status(500).json({
            success: false,
            error: 'Erro ao remover prefer√™ncias',
            code: 'DELETE_PREFERENCES_ERROR'
        });
    }
});

console.log('‚úÖ Rotas de perfil carregadas com PostgreSQL');

export default router;
EOF

echo -e "${GREEN}‚úÖ Rotas de perfil atualizadas${NC}"

# 7. ATUALIZAR .env
echo -e "${BLUE}‚öôÔ∏è  Atualizando configura√ß√µes de ambiente...${NC}"

# Backup do .env atual se existir
if [ -f ".env" ]; then
    cp .env ".env.backup.$(date +%Y%m%d_%H%M%S)"
fi

cat > .env << 'EOF'
# Configura√ß√µes do Banco de Dados - FASE 0
DB_HOST=localhost
DB_PORT=5432
DB_NAME=matchit_db
DB_USER=matchit
DB_PASSWORD=matchit123

# Configura√ß√µes da API
PORT=3000
NODE_ENV=development
JWT_SECRET=matchit_secret_key_phase0_2025

# URLs da API
API_URL=http://localhost:3000
EXPO_PUBLIC_API_URL=http://localhost:3000

# Configura√ß√µes de Upload
UPLOAD_PATH=./uploads
MAX_FILE_SIZE=5242880

# Logs
LOG_LEVEL=info
LOG_FILE=./logs/app.log
EOF

echo -e "${GREEN}‚úÖ Arquivo .env atualizado${NC}"

# 8. INSTALAR DEPEND√äNCIA PG
echo -e "${BLUE}üì¶ Instalando depend√™ncia PostgreSQL...${NC}"

npm install pg

echo -e "${GREEN}‚úÖ Depend√™ncia pg instalada${NC}"

# 9. CRIAR SCRIPT DE TESTE DA FASE 0
echo -e "${BLUE}üß™ Criando script de teste...${NC}"

mkdir -p tests

cat > tests/test-phase-0.mjs << 'EOF'
// tests/test-phase-0.mjs - Teste da Fase 0 complet–∞
import http from 'http';

const API_BASE = 'http://localhost:3000';

// Fun√ß√£o helper para fazer requests
function makeRequest(path, options = {}) {
    return new Promise((resolve, reject) => {
        const url = new URL(path, API_BASE);
        const reqOptions = {
            hostname: url.hostname,
            port: url.port,
            path: url.pathname + url.search,
            method: options.method || 'GET',
            headers: {
                'Content-Type': 'application/json',
                ...options.headers
            }
        };

        const req = http.request(reqOptions, (res) => {
            let data = '';
            res.on('data', chunk => data += chunk);
            res.on('end', () => {
                try {
                    const parsed = JSON.parse(data);
                    resolve({ status: res.statusCode, data: parsed, headers: res.headers });
                } catch (e) {
                    resolve({ status: res.statusCode, data: data, headers: res.headers });
                }
            });
        });

        req.on('error', reject);

        if (options.body) {
            req.write(JSON.stringify(options.body));
        }

        req.end();
    });
}

// Testes
async function runTests() {
    console.log('üß™ Iniciando testes da Fase 0...\n');
    
    let passedTests = 0;
    let totalTests = 0;
    
    // Teste 1: Health check
    totalTests++;
    console.log('1Ô∏è‚É£  Testando health check...');
    try {
        const response = await makeRequest('/api/health');
        if (response.status === 200 && response.data.status === 'healthy') {
            console.log('   ‚úÖ Health check OK');
            passedTests++;
        } else {
            console.log('   ‚ùå Health check falhou');
        }
    } catch (error) {
        console.log('   ‚ùå Erro:', error.message);
    }
    
    // Teste 2: Buscar prefer√™ncias (deve retornar vazio inicialmente)
    totalTests++;
    console.log('2Ô∏è‚É£  Testando GET /api/profile/style-preferences...');
    try {
        const response = await makeRequest('/api/profile/style-preferences');
        if (response.status === 200 && response.data.success) {
            console.log('   ‚úÖ GET style-preferences OK');
            console.log('   üìä Dados retornados:', JSON.stringify(response.data.data, null, 2));
            passedTests++;
        } else {
            console.log('   ‚ùå GET style-preferences falhou');
        }
    } catch (error) {
        console.log('   ‚ùå Erro:', error.message);
    }
    
    // Teste 3: Criar prefer√™ncia
    totalTests++;
    console.log('3Ô∏è‚É£  Testando PUT /api/profile/style-preferences...');
    try {
        const response = await makeRequest('/api/profile/style-preferences', {
            method: 'PUT',
            body: {
                category: 'colors',
                questionId: 'warm_vs_cool',
                selectedOption: 'warm_colors',
                preferenceStrength: 0.8
            }
        });
        
        if (response.status === 200 && response.data.success) {
            console.log('   ‚úÖ PUT style-preferences OK');
            console.log('   üíæ Prefer√™ncia criada:', response.data.data.selectedOption);
            passedTests++;
        } else {
            console.log('   ‚ùå PUT style-preferences falhou');
            console.log('   üìã Response:', response.data);
        }
    } catch (error) {
        console.log('   ‚ùå Erro:', error.message);
    }
    
    // Teste 4: Buscar prefer√™ncias novamente (deve retornar a criada)
    totalTests++;
    console.log('4Ô∏è‚É£  Testando GET ap√≥s criar prefer√™ncia...');
    try {
        const response = await makeRequest('/api/profile/style-preferences');
        if (response.status === 200 && response.data.success) {
            const hasColors = response.data.data.colors && response.data.data.colors.warm_vs_cool;
            if (hasColors) {
                console.log('   ‚úÖ Prefer√™ncia persistida corretamente');
                console.log('   üìä Valor salvo:', response.data.data.colors.warm_vs_cool.selectedOption);
                passedTests++;
            } else {
                console.log('   ‚ùå Prefer√™ncia n√£o foi persistida');
            }
        } else {
            console.log('   ‚ùå GET ap√≥s create falhou');
        }
    } catch (error) {
        console.log('   ‚ùå Erro:', error.message);
    }
    
    // Teste 5: Testar batch update
    totalTests++;
    console.log('5Ô∏è‚É£  Testando POST /api/profile/style-preferences/batch...');
    try {
        const response = await makeRequest('/api/profile/style-preferences/batch', {
            method: 'POST',
            body: {
                preferences: {
                    styles: {
                        casual_vs_formal: { selectedOption: 'casual', preferenceStrength: 0.9 },
                        minimalist_vs_bold: { selectedOption: 'minimalist', preferenceStrength: 0.7 }
                    },
                    accessories: {
                        gold_vs_silver: { selectedOption: 'silver', preferenceStrength: 0.6 }
                    }
                }
            }
        });
        
        if (response.status === 200 && response.data.success) {
            console.log('   ‚úÖ Batch update OK');
            console.log('   üíæ Prefer√™ncias atualizadas:', response.data.totalUpdated);
            passedTests++;
        } else {
            console.log('   ‚ùå Batch update falhou');
        }
    } catch (error) {
        console.log('   ‚ùå Erro:', error.message);
    }
    
    // Teste 6: Testar estat√≠sticas
    totalTests++;
    console.log('6Ô∏è‚É£  Testando GET /api/profile/style-preferences/stats...');
    try {
        const response = await makeRequest('/api/profile/style-preferences/stats');
        if (response.status === 200 && response.data.success) {
            console.log('   ‚úÖ Estat√≠sticas OK');
            console.log('   üìä Completude:', response.data.data.completionPercentage + '%');
            console.log('   üìä Respostas:', response.data.data.totalAnsweredQuestions);
            passedTests++;
        } else {
            console.log('   ‚ùå Estat√≠sticas falharam');
        }
    } catch (error) {
        console.log('   ‚ùå Erro:', error.message);
    }
    
    // Relat√≥rio final
    console.log('\n' + '='.repeat(50));
    console.log('üìä RELAT√ìRIO FINAL DOS TESTES - FASE 0');
    console.log('='.repeat(50));
    console.log(`‚úÖ Testes passados: ${passedTests}/${totalTests}`);
    console.log(`üìä Taxa de sucesso: ${Math.round((passedTests/totalTests)*100)}%`);
    
    if (passedTests === totalTests) {
        console.log('üéâ FASE 0 COMPLETAMENTE FUNCIONAL!');
        console.log('‚úÖ Integra√ß√£o PostgreSQL OK');
        console.log('‚úÖ Todas as opera√ß√µes CRUD funcionando');
        console.log('‚úÖ Persist√™ncia de dados confirmada');
        console.log('üöÄ Pronto para Fase 1!');
    } else {
        console.log('‚ö†Ô∏è  Alguns testes falharam. Revisar implementa√ß√£o.');
    }
    
    process.exit(passedTests === totalTests ? 0 : 1);
}

runTests().catch(console.error);
EOF

echo -e "${GREEN}‚úÖ Script de teste criado${NC}"

# 10. FINALIZA√á√ÉO
echo -e "${GREEN}"
echo "================================================================"
echo " FASE 0 COMPLETADA COM SUCESSO!"
echo "================================================================"
echo -e "${NC}"

echo -e "${GREEN}‚úÖ Implementa√ß√µes conclu√≠das:${NC}"
echo "   ‚Ä¢ PostgreSQL configurado e funcionando"
echo "   ‚Ä¢ Migra√ß√£o de banco executada"
echo "   ‚Ä¢ Servi√ßo de prefer√™ncias de estilo implementado"
echo "   ‚Ä¢ Rotas de perfil conectadas ao banco real"
echo "   ‚Ä¢ Endpoints CRUD funcionais"
echo "   ‚Ä¢ Sistema de estat√≠sticas implementado"
echo "   ‚Ä¢ Testes automatizados criados"

echo ""
echo -e "${BLUE}üöÄ Para testar a Fase 0 completa:${NC}"
echo "   1. Reinicie o servidor: npm run server"
echo "   2. Execute os testes: node tests/test-phase-0.mjs" 
echo "   3. Verifique os dados: psql -U matchit -d matchit_db -c \"SELECT * FROM style_preferences;\""

echo ""
echo -e "${BLUE}üìã Endpoints implementados:${NC}"
echo "   GET    /api/profile/style-preferences           - Buscar todas as prefer√™ncias"
echo "   GET    /api/profile/style-preferences?category=X - Buscar por categoria"
echo "   PUT    /api/profile/style-preferences           - Atualizar prefer√™ncia espec√≠fica"
echo "   POST   /api/profile/style-preferences/batch     - Atualizar m√∫ltiplas prefer√™ncias"
echo "   GET    /api/profile/style-preferences/stats     - Estat√≠sticas de completude"
echo "   DELETE /api/profile/style-preferences           - Remover todas as prefer√™ncias"

echo ""
echo -e "${YELLOW}üí° A Fase 0 agora est√° 100% funcional com PostgreSQL real!${NC}"
echo -e "${YELLOW}   Pr√≥ximo passo: Conectar frontend React Native${NC}"
echo ""
