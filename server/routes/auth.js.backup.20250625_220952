// server/routes/auth.js - Rotas compat√≠veis com estrutura real (ES Modules)
import express from 'express';
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import { query } from '../config/database.js';

const router = express.Router();

const generateToken = (userId) => {
  return jwt.sign(
    { userId },
    process.env.JWT_SECRET || 'matchit-default-secret',
    { expiresIn: process.env.JWT_EXPIRES_IN || '7d' }
  );
};

// POST /api/auth/register - Compat√≠vel com estrutura UUID
router.post('/register', async (req, res) => {
  try {
    console.log('üìù Registro solicitado:', { email: req.body.email, name: req.body.name });
    
    const { email, password, name } = req.body;
    
    if (!email || !password || !name) {
      console.log('‚ùå Campos obrigat√≥rios faltando');
      return res.status(400).json({
        success: false,
        error: 'Email, senha e nome s√£o obrigat√≥rios',
        code: 'MISSING_FIELDS'
      });
    }
    
    if (password.length < 6) {
      console.log('‚ùå Senha muito fraca');
      return res.status(400).json({
        success: false,
        error: 'Senha deve ter pelo menos 6 caracteres',
        code: 'WEAK_PASSWORD'
      });
    }
    
    // Verificar se email j√° existe
    console.log('üîç Verificando se email existe:', email);
    const existingUser = await query('SELECT id FROM users WHERE email = $1', [email]);
    
    if (existingUser.rows.length > 0) {
      console.log('‚ùå Email j√° existe');
      return res.status(400).json({
        success: false,
        error: 'Email j√° est√° em uso',
        code: 'EMAIL_EXISTS'
      });
    }
    
    // Hash da senha
    console.log('üîí Gerando hash da senha...');
    const hashedPassword = await bcrypt.hash(password, 10);
    
    // Inserir usu√°rio - ADAPTADO para estrutura real
    console.log('üíæ Inserindo usu√°rio no banco...');
    
    let insertQuery;
    let insertParams;
    
    if ('uuid' === 'uuid') {
      // Para UUID: gerar UUID automaticamente
      if ('password' === 'password_hash') {
        insertQuery = 'INSERT INTO users (email, password_hash, name) VALUES ($1, $2, $3) RETURNING id, email, name';
      } else {
        insertQuery = 'INSERT INTO users (email, password, name) VALUES ($1, $2, $3) RETURNING id, email, name';
      }
      insertParams = [email, hashedPassword, name];
    } else {
      // Para SERIAL: ID gerado automaticamente
      if ('password' === 'password_hash') {
        insertQuery = 'INSERT INTO users (email, password_hash, name) VALUES ($1, $2, $3) RETURNING id, email, name';
      } else {
        insertQuery = 'INSERT INTO users (email, password, name) VALUES ($1, $2, $3) RETURNING id, email, name';
      }
      insertParams = [email, hashedPassword, name];
    }
    
    console.log('üìù Query:', insertQuery);
    const result = await query(insertQuery, insertParams);
    
    if (result.rows.length === 0) {
      console.log('‚ùå Falha ao inserir usu√°rio');
      return res.status(500).json({
        success: false,
        error: 'Falha ao criar usu√°rio',
        code: 'INSERT_FAILED'
      });
    }
    
    const user = result.rows[0];
    console.log('‚úÖ Usu√°rio criado:', { id: user.id, email: user.email });
    
    const token = generateToken(user.id);
    
    res.status(201).json({
      success: true,
      message: 'Usu√°rio registrado com sucesso',
      user: {
        id: user.id,
        email: user.email,
        name: user.name
      },
      token
    });
    
  } catch (error) {
    console.error('‚ùå Erro no registro:', error);
    res.status(500).json({
      success: false,
      error: 'Erro interno do servidor',
      code: 'INTERNAL_ERROR',
      details: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

// POST /api/auth/login - Compat√≠vel com estrutura real
router.post('/login', async (req, res) => {
  try {
    console.log('üîê Login solicitado:', { email: req.body.email });
    
    const { email, password } = req.body;
    
    if (!email || !password) {
      return res.status(400).json({
        success: false,
        error: 'Email e senha s√£o obrigat√≥rios',
        code: 'MISSING_FIELDS'
      });
    }
    
    // Buscar usu√°rio - ADAPTADO para campo de senha correto
    let selectQuery;
    if ('password' === 'password_hash') {
      selectQuery = 'SELECT id, email, name, password_hash as password FROM users WHERE email = $1';
    } else {
      selectQuery = 'SELECT id, email, name, password FROM users WHERE email = $1';
    }
    
    console.log('üîç Buscando usu√°rio...');
    const result = await query(selectQuery, [email]);
    
    if (result.rows.length === 0) {
      console.log('‚ùå Usu√°rio n√£o encontrado');
      return res.status(401).json({
        success: false,
        error: 'Credenciais inv√°lidas',
        code: 'INVALID_CREDENTIALS'
      });
    }
    
    const user = result.rows[0];
    console.log('üîç Verificando senha...');
    const isValidPassword = await bcrypt.compare(password, user.password);
    
    if (!isValidPassword) {
      console.log('‚ùå Senha inv√°lida');
      return res.status(401).json({
        success: false,
        error: 'Credenciais inv√°lidas',
        code: 'INVALID_CREDENTIALS'
      });
    }
    
    const token = generateToken(user.id);
    console.log('‚úÖ Login bem-sucedido');
    
    res.json({
      success: true,
      message: 'Login realizado com sucesso',
      user: {
        id: user.id,
        email: user.email,
        name: user.name
      },
      token
    });
    
  } catch (error) {
    console.error('‚ùå Erro no login:', error);
    res.status(500).json({
      success: false,
      error: 'Erro interno do servidor',
      code: 'INTERNAL_ERROR',
      details: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

// GET /api/auth/me - Verificar token
router.get('/me', async (req, res) => {
  try {
    const authHeader = req.headers.authorization;
    
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({
        success: false,
        error: 'Token necess√°rio',
        code: 'NO_TOKEN'
      });
    }
    
    const token = authHeader.substring(7);
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'matchit-default-secret');
    
    const result = await query('SELECT id, email, name FROM users WHERE id = $1', [decoded.userId]);
    
    if (result.rows.length === 0) {
      return res.status(401).json({
        success: false,
        error: 'Usu√°rio n√£o encontrado',
        code: 'USER_NOT_FOUND'
      });
    }
    
    res.json({
      success: true,
      user: result.rows[0]
    });
    
  } catch (error) {
    res.status(401).json({
      success: false,
      error: 'Token inv√°lido',
      code: 'INVALID_TOKEN'
    });
  }
});

// GET /api/auth/test - Endpoint de teste
router.get('/test', (req, res) => {
  res.json({
    success: true,
    message: 'Rotas de autentica√ß√£o funcionando!',
    timestamp: new Date().toISOString(),
    endpoints: [
      'POST /api/auth/register',
      'POST /api/auth/login', 
      'GET /api/auth/me',
      'GET /api/auth/test'
    ]
  });
});

export default router;
