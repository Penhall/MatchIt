// server/middleware/auth.js - Middleware de autentica√ß√£o funcional para MatchIt
import jwt from 'jsonwebtoken';
import { pool } from '../config/database.js';

const JWT_SECRET = process.env.JWT_SECRET; // Removido o valor padr√£o hardcoded
console.log('üîë JWT_SECRET (middleware):', JWT_SECRET); // Adicionado para depura√ß√£o

/**
 * Middleware de autentica√ß√£o obrigat√≥ria
 */
export const authenticateToken = async (req, res, next) => {
    try {
        // Extrair token do header Authorization
        const authHeader = req.headers.authorization;
        
        if (!authHeader) {
            return res.status(401).json({
                success: false,
                error: 'Token de acesso obrigat√≥rio',
                code: 'MISSING_TOKEN'
            });
        }
        
        // Verificar formato do token (Bearer <token>)
        if (!authHeader.startsWith('Bearer ')) {
            return res.status(401).json({
                success: false,
                error: 'Formato de token inv√°lido. Use: Bearer <token>',
                code: 'INVALID_TOKEN_FORMAT'
            });
        }
        
        const token = authHeader.substring(7); // Remove "Bearer "
        
        // Para desenvolvimento, aceitar token "test-token"
        if (process.env.NODE_ENV === 'development' && token === 'test-token') {
            req.user = {
                id: 1,
                userId: 1,
                name: 'Usu√°rio Teste',
                email: 'teste@matchit.com',
                isTestUser: true
            };
            return next();
        }
        
        // Verificar e decodificar JWT
        let decoded;
        try {
            decoded = jwt.verify(token, JWT_SECRET);
        } catch (jwtError) {
            console.error('‚ùå Erro JWT:', jwtError.message);
            
            if (jwtError.name === 'TokenExpiredError') {
                return res.status(401).json({
                    success: false,
                    error: 'Token expirado',
                    code: 'TOKEN_EXPIRED'
                });
            } else if (jwtError.name === 'JsonWebTokenError') {
                return res.status(401).json({
                    success: false,
                    error: 'Token inv√°lido',
                    code: 'INVALID_TOKEN'
                });
            } else {
                return res.status(401).json({
                    success: false,
                    error: 'Falha na valida√ß√£o do token',
                    code: 'TOKEN_VALIDATION_FAILED'
                });
            }
        }
        
        // Buscar usu√°rio no banco de dados
        const userResult = await pool.query(
            'SELECT id, name, email, is_active FROM users WHERE id = $1',
            [decoded.id] // Alterado para decoded.id
        );
        
        if (userResult.rows.length === 0) {
            return res.status(401).json({
                success: false,
                error: 'Usu√°rio n√£o encontrado',
                code: 'USER_NOT_FOUND'
            });
        }
        
        const user = userResult.rows[0];
        
        // Verificar se usu√°rio est√° ativo
        if (!user.is_active) {
            return res.status(401).json({
                success: false,
                error: 'Conta desativada',
                code: 'ACCOUNT_DISABLED'
            });
        }
        
        // Adicionar informa√ß√µes do usu√°rio √† requisi√ß√£o
        req.user = {
            id: user.id,
            userId: user.id, // Para compatibilidade
            name: user.name,
            email: user.email,
            isActive: user.is_active,
            tokenData: decoded
        };
        
        console.log('‚úÖ Token validado para usu√°rio:', user.email);
        next();
        
    } catch (error) {
        console.error('‚ùå Erro no middleware de autentica√ß√£o:', error);
        res.status(500).json({
            success: false,
            error: 'Erro interno de autentica√ß√£o',
            code: 'AUTH_INTERNAL_ERROR'
        });
    }
};

/**
 * Middleware de autentica√ß√£o opcional (n√£o bloqueia se n√£o houver token)
 */
export const optionalAuth = async (req, res, next) => {
    try {
        const authHeader = req.headers.authorization;
        
        // Se n√£o h√° token, continuar sem autentica√ß√£o
        if (!authHeader || !authHeader.startsWith('Bearer ')) {
            req.user = null;
            return next();
        }
        
        // Se h√° token, tentar autenticar
        await authenticateToken(req, res, next);
        
    } catch (error) {
        // Em caso de erro, continuar sem autentica√ß√£o
        req.user = null;
        next();
    }
};

export default authenticateToken;
